-- Problem 44: Pentagon numbers
-- Pentagonal numbers are generated by the formula, P[n]=n(3n-1)/2. The first
-- ten pentagonal numbers are:
--                1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
-- It can be seen that P[4] + P[7] = 22 + 70 = 92 = P[8]. However, their
-- difference, 70 - 22 = 48, is not pentagonal.
-- Find the pair of pentagonal numbers, P[j] and P[k], for which their sum
-- and difference is pentagonal and D = |P[k] - P[j]| is minimised; what is
-- the value of D?
pentagonal :: Int -> Int
pentagonal n = n * (3 * n - 1) `div` 2

pentagonals :: [Int]
pentagonals = map pentagonal [1 ..]

quadratic
  :: Double -> Double -> Double -> [Double]
quadratic a b c = [(-b + sroot) / (2 * a),(-b - sroot) / (2 * a)]
  where sroot = sqrt ((b ^ 2) - (4 * a * c))

-- truncate, round, ceiling, floor
isPentagonal :: Int -> Bool
isPentagonal p = (isZero . head) (quadratic a b c)
  where a = 1.5
        b = -0.5
        c = -(fromIntegral p)
        isZero = (== 0) . snd . properFraction

nPairs :: Int -> [(Int,Int)]
nPairs n =
  zip (repeat n)
      [n + 1 ..]

-- allPairs = interleave (nPairs 1) (interleave (nPairs 2))
-- foldl1 interleave (map nPairs [1..])
-- il :: Int -> [(Int,Int)]
-- il n =
--   interleave (nPairs n)
--              (il (n + 1))
interleave :: [a] -> [a] -> [a]
interleave [] ys = ys
interleave (x:xs) ys = x : (interleave ys xs)

posPairs :: [(Int,Int)]
posPairs =
  zip (concat [[1 .. n]|n <- [1 ..]])
      (concat [replicate n (n + 1)|n <- [1 ..]])

-- take 1 (filter (\(x,y) -> (elem x pentagonals) && (elem x pentagonals)) (zip (map (penOp (+)) posPairs) (map (penOp (-)) posPairs)))
penOp :: (Int -> Int -> Int) -> (Int,Int) -> Int
penOp op (n,m) =
  op (pentagonal m)
     (pentagonal n)

filterSnd :: (b -> Bool) -> [(a,b)] -> [(a,b)]
filterSnd p xs = filter (p . snd) xs

pentagonalNths
  :: (Int -> Int -> Int) -> [(Int,Int)]
pentagonalNths op =
  filter (isPentagonal . snd)
         (zip [1 ..]
              (map (penOp op) posPairs))

-- [(2345715,8602840,5482660)]
findFstMatches
  :: [(Int,Int)] -> [(Int,Int)] -> [(Int,Int,Int)]
findFstMatches [] _ = []
findFstMatches _ [] = []
findFstMatches ((ax,bx):xs) ((ay,by):ys)
  | ax > ay =
    findFstMatches ((ax,bx) : xs)
                   ys
  | ax < ay =
    findFstMatches xs
                   ((ay,by) : ys)
  | otherwise = (ax,bx,by) : (findFstMatches xs ys)

p44 :: Int
p44 =
  ((\(_,_,x) -> x) . head)
    (findFstMatches (pentagonalNths (+))
                    (pentagonalNths (-)))