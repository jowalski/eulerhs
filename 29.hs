import Data.List.Ordered (minus, union, unionAll)

-- Problem 29: Distinct powers
-- Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:
--   2^2=4, 2^3=8, 2^4=16, 2^5=32
--   3^2=9, 3^3=27, 3^4=81, 3^5=243
--   4^2=16, 4^3=64, 4^4=256, 4^5=1024
--   5^2=25, 5^3=125, 5^4=625, 5^5=3125
-- If they are then placed in numerical order, with any repeats removed, we
-- get the following sequence of 15 distinct terms:
--      4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
-- How many distinct terms are in the sequence generated by a^b for
-- 2 <= a <= 100 and 2 <= b <= 100?
--
--  4  8   16   32
--  9 27   81  243
-- 16 64  256 1024
-- 25 125 625 3125
data Pow =
  Pow Int
      Int
  deriving (((((((((((Show)))))))))))

divTimes :: Int -> Int -> Int
divTimes n d
  | n `mod` d /= 0 = 0
  | otherwise = 1 + divTimes (n `div` d) d

pfs :: [Int] -> Int -> [(Int,Int)]
pfs ps n
  | n == 1 = []
  | otherwise =
    case divTimes n p of
      0 -> pfs (tail ps) n
      d ->
        (p,d) :
        (pfs (tail ps)
             (n `div` (p ^ d)))
  where p = head ps

primeFactors :: Int -> [(Int,Int)]
primeFactors = pfs primes

reducePow :: Pow -> [(Int,Int)]
reducePow (Pow a b) =
  map (\(x,p) -> (x,p * b))
      (primeFactors a)

evalPow :: Pow -> Integer
evalPow (Pow a b) = (toInteger a) ^ (toInteger b)

instance Eq Pow where
  (==) x y = compare x y == EQ

instance Ord Pow where
  compare x y =
    compare (evalPow x)
            (evalPow y)

-- compare (reducePow x)
--         (reducePow y)
primes :: [Int]
primes =
  2 :
  3 :
  minus [5,7 ..]
        (unionAll [[p * p,p * p + 2 * p ..]|p <- tail primes])

-- primes100 = takeWhile (< 100) primes
ab :: Int -> Int -> Int
ab a b = a ^ b

abcombs :: Int -> [Pow]
abcombs n = [Pow a b|a <- [2 .. n],b <- [2 .. n]]

insertOrdUnique :: Ord a
                => a -> [a] -> [a]
insertOrdUnique i [] = [i]
insertOrdUnique i (x:xs)
  | i < x = i : x : xs
  | i == x = x : xs
  | otherwise = x : (insertOrdUnique i xs)

-- length (makeOrdSet (map reducePow (abcombs 100)))
makeOrdSet :: Ord a
           => [a] -> [a]
makeOrdSet = foldr insertOrdUnique []